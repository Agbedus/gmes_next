"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polylabel";
exports.ids = ["vendor-chunks/polylabel"];
exports.modules = {

/***/ "(ssr)/./node_modules/polylabel/polylabel.js":
/*!*********************************************!*\
  !*** ./node_modules/polylabel/polylabel.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar Queue = __webpack_require__(/*! tinyqueue */ \"(ssr)/./node_modules/tinyqueue/index.js\");\n\nif (Queue.default) Queue = Queue.default; // temporary webpack fix\n\nmodule.exports = polylabel;\nmodule.exports[\"default\"] = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n    precision = precision || 1.0;\n\n    // find the bounding box of the outer ring\n    var minX, minY, maxX, maxY;\n    for (var i = 0; i < polygon[0].length; i++) {\n        var p = polygon[0][i];\n        if (!i || p[0] < minX) minX = p[0];\n        if (!i || p[1] < minY) minY = p[1];\n        if (!i || p[0] > maxX) maxX = p[0];\n        if (!i || p[1] > maxY) maxY = p[1];\n    }\n\n    var width = maxX - minX;\n    var height = maxY - minY;\n    var cellSize = Math.min(width, height);\n    var h = cellSize / 2;\n\n    if (cellSize === 0) {\n        var degeneratePoleOfInaccessibility = [minX, minY];\n        degeneratePoleOfInaccessibility.distance = 0;\n        return degeneratePoleOfInaccessibility;\n    }\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    var cellQueue = new Queue(undefined, compareMax);\n\n    // cover polygon with initial cells\n    for (var x = minX; x < maxX; x += cellSize) {\n        for (var y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygon));\n        }\n    }\n\n    // take centroid as the first best guess\n    var bestCell = getCentroidCell(polygon);\n\n    // special case for rectangular polygons\n    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n    if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n    var numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        var cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log('num probes: ' + numProbes);\n        console.log('best distance: ' + bestCell.d);\n    }\n\n    var poleOfInaccessibility = [bestCell.x, bestCell.y];\n    poleOfInaccessibility.distance = bestCell.d;\n    return poleOfInaccessibility;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n        var ring = polygon[k];\n\n        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            var a = ring[i];\n            var b = ring[j];\n\n            if ((a[1] > y !== b[1] > y) &&\n                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n        }\n    }\n\n    return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        var a = points[i];\n        var b = points[j];\n        var f = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * f;\n        y += (a[1] + b[1]) * f;\n        area += f * 3;\n    }\n    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n    return new Cell(x / area, y / area, 0, polygon);\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n\n    var x = a[0];\n    var y = a[1];\n    var dx = b[0] - x;\n    var dy = b[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = b[0];\n            y = b[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9seWxhYmVsL3BvbHlsYWJlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQVc7O0FBRS9CLDBDQUEwQzs7QUFFMUM7QUFDQSx5QkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0RBQWdEO0FBQ2hELDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3lhd2Rvbmtvci9EZXNrdG9wL2dpdC1yZXBvcy9nbWVzX25leHQvbm9kZV9tb2R1bGVzL3BvbHlsYWJlbC9wb2x5bGFiZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUXVldWUgPSByZXF1aXJlKCd0aW55cXVldWUnKTtcblxuaWYgKFF1ZXVlLmRlZmF1bHQpIFF1ZXVlID0gUXVldWUuZGVmYXVsdDsgLy8gdGVtcG9yYXJ5IHdlYnBhY2sgZml4XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWxhYmVsO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBvbHlsYWJlbDtcblxuZnVuY3Rpb24gcG9seWxhYmVsKHBvbHlnb24sIHByZWNpc2lvbiwgZGVidWcpIHtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMS4wO1xuXG4gICAgLy8gZmluZCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBvdXRlciByaW5nXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcG9seWdvblswXVtpXTtcbiAgICAgICAgaWYgKCFpIHx8IHBbMF0gPCBtaW5YKSBtaW5YID0gcFswXTtcbiAgICAgICAgaWYgKCFpIHx8IHBbMV0gPCBtaW5ZKSBtaW5ZID0gcFsxXTtcbiAgICAgICAgaWYgKCFpIHx8IHBbMF0gPiBtYXhYKSBtYXhYID0gcFswXTtcbiAgICAgICAgaWYgKCFpIHx8IHBbMV0gPiBtYXhZKSBtYXhZID0gcFsxXTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBtYXhYIC0gbWluWDtcbiAgICB2YXIgaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG4gICAgdmFyIGNlbGxTaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIGggPSBjZWxsU2l6ZSAvIDI7XG5cbiAgICBpZiAoY2VsbFNpemUgPT09IDApIHtcbiAgICAgICAgdmFyIGRlZ2VuZXJhdGVQb2xlT2ZJbmFjY2Vzc2liaWxpdHkgPSBbbWluWCwgbWluWV07XG4gICAgICAgIGRlZ2VuZXJhdGVQb2xlT2ZJbmFjY2Vzc2liaWxpdHkuZGlzdGFuY2UgPSAwO1xuICAgICAgICByZXR1cm4gZGVnZW5lcmF0ZVBvbGVPZkluYWNjZXNzaWJpbGl0eTtcbiAgICB9XG5cbiAgICAvLyBhIHByaW9yaXR5IHF1ZXVlIG9mIGNlbGxzIGluIG9yZGVyIG9mIHRoZWlyIFwicG90ZW50aWFsXCIgKG1heCBkaXN0YW5jZSB0byBwb2x5Z29uKVxuICAgIHZhciBjZWxsUXVldWUgPSBuZXcgUXVldWUodW5kZWZpbmVkLCBjb21wYXJlTWF4KTtcblxuICAgIC8vIGNvdmVyIHBvbHlnb24gd2l0aCBpbml0aWFsIGNlbGxzXG4gICAgZm9yICh2YXIgeCA9IG1pblg7IHggPCBtYXhYOyB4ICs9IGNlbGxTaXplKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSBtaW5ZOyB5IDwgbWF4WTsgeSArPSBjZWxsU2l6ZSkge1xuICAgICAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoeCArIGgsIHkgKyBoLCBoLCBwb2x5Z29uKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0YWtlIGNlbnRyb2lkIGFzIHRoZSBmaXJzdCBiZXN0IGd1ZXNzXG4gICAgdmFyIGJlc3RDZWxsID0gZ2V0Q2VudHJvaWRDZWxsKHBvbHlnb24pO1xuXG4gICAgLy8gc3BlY2lhbCBjYXNlIGZvciByZWN0YW5ndWxhciBwb2x5Z29uc1xuICAgIHZhciBiYm94Q2VsbCA9IG5ldyBDZWxsKG1pblggKyB3aWR0aCAvIDIsIG1pblkgKyBoZWlnaHQgLyAyLCAwLCBwb2x5Z29uKTtcbiAgICBpZiAoYmJveENlbGwuZCA+IGJlc3RDZWxsLmQpIGJlc3RDZWxsID0gYmJveENlbGw7XG5cbiAgICB2YXIgbnVtUHJvYmVzID0gY2VsbFF1ZXVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChjZWxsUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBpY2sgdGhlIG1vc3QgcHJvbWlzaW5nIGNlbGwgZnJvbSB0aGUgcXVldWVcbiAgICAgICAgdmFyIGNlbGwgPSBjZWxsUXVldWUucG9wKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBiZXN0IGNlbGwgaWYgd2UgZm91bmQgYSBiZXR0ZXIgb25lXG4gICAgICAgIGlmIChjZWxsLmQgPiBiZXN0Q2VsbC5kKSB7XG4gICAgICAgICAgICBiZXN0Q2VsbCA9IGNlbGw7XG4gICAgICAgICAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKCdmb3VuZCBiZXN0ICVkIGFmdGVyICVkIHByb2JlcycsIE1hdGgucm91bmQoMWU0ICogY2VsbC5kKSAvIDFlNCwgbnVtUHJvYmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvIG5vdCBkcmlsbCBkb3duIGZ1cnRoZXIgaWYgdGhlcmUncyBubyBjaGFuY2Ugb2YgYSBiZXR0ZXIgc29sdXRpb25cbiAgICAgICAgaWYgKGNlbGwubWF4IC0gYmVzdENlbGwuZCA8PSBwcmVjaXNpb24pIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBjZWxsIGludG8gZm91ciBjZWxsc1xuICAgICAgICBoID0gY2VsbC5oIC8gMjtcbiAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoY2VsbC54IC0gaCwgY2VsbC55IC0gaCwgaCwgcG9seWdvbikpO1xuICAgICAgICBjZWxsUXVldWUucHVzaChuZXcgQ2VsbChjZWxsLnggKyBoLCBjZWxsLnkgLSBoLCBoLCBwb2x5Z29uKSk7XG4gICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKGNlbGwueCAtIGgsIGNlbGwueSArIGgsIGgsIHBvbHlnb24pKTtcbiAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoY2VsbC54ICsgaCwgY2VsbC55ICsgaCwgaCwgcG9seWdvbikpO1xuICAgICAgICBudW1Qcm9iZXMgKz0gNDtcbiAgICB9XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ251bSBwcm9iZXM6ICcgKyBudW1Qcm9iZXMpO1xuICAgICAgICBjb25zb2xlLmxvZygnYmVzdCBkaXN0YW5jZTogJyArIGJlc3RDZWxsLmQpO1xuICAgIH1cblxuICAgIHZhciBwb2xlT2ZJbmFjY2Vzc2liaWxpdHkgPSBbYmVzdENlbGwueCwgYmVzdENlbGwueV07XG4gICAgcG9sZU9mSW5hY2Nlc3NpYmlsaXR5LmRpc3RhbmNlID0gYmVzdENlbGwuZDtcbiAgICByZXR1cm4gcG9sZU9mSW5hY2Nlc3NpYmlsaXR5O1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTWF4KGEsIGIpIHtcbiAgICByZXR1cm4gYi5tYXggLSBhLm1heDtcbn1cblxuZnVuY3Rpb24gQ2VsbCh4LCB5LCBoLCBwb2x5Z29uKSB7XG4gICAgdGhpcy54ID0geDsgLy8gY2VsbCBjZW50ZXIgeFxuICAgIHRoaXMueSA9IHk7IC8vIGNlbGwgY2VudGVyIHlcbiAgICB0aGlzLmggPSBoOyAvLyBoYWxmIHRoZSBjZWxsIHNpemVcbiAgICB0aGlzLmQgPSBwb2ludFRvUG9seWdvbkRpc3QoeCwgeSwgcG9seWdvbik7IC8vIGRpc3RhbmNlIGZyb20gY2VsbCBjZW50ZXIgdG8gcG9seWdvblxuICAgIHRoaXMubWF4ID0gdGhpcy5kICsgdGhpcy5oICogTWF0aC5TUVJUMjsgLy8gbWF4IGRpc3RhbmNlIHRvIHBvbHlnb24gd2l0aGluIGEgY2VsbFxufVxuXG4vLyBzaWduZWQgZGlzdGFuY2UgZnJvbSBwb2ludCB0byBwb2x5Z29uIG91dGxpbmUgKG5lZ2F0aXZlIGlmIHBvaW50IGlzIG91dHNpZGUpXG5mdW5jdGlvbiBwb2ludFRvUG9seWdvbkRpc3QoeCwgeSwgcG9seWdvbikge1xuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICB2YXIgbWluRGlzdFNxID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvbHlnb24ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW2tdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5nLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcbiAgICAgICAgICAgIHZhciBhID0gcmluZ1tpXTtcbiAgICAgICAgICAgIHZhciBiID0gcmluZ1tqXTtcblxuICAgICAgICAgICAgaWYgKChhWzFdID4geSAhPT0gYlsxXSA+IHkpICYmXG4gICAgICAgICAgICAgICAgKHggPCAoYlswXSAtIGFbMF0pICogKHkgLSBhWzFdKSAvIChiWzFdIC0gYVsxXSkgKyBhWzBdKSkgaW5zaWRlID0gIWluc2lkZTtcblxuICAgICAgICAgICAgbWluRGlzdFNxID0gTWF0aC5taW4obWluRGlzdFNxLCBnZXRTZWdEaXN0U3EoeCwgeSwgYSwgYikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbkRpc3RTcSA9PT0gMCA/IDAgOiAoaW5zaWRlID8gMSA6IC0xKSAqIE1hdGguc3FydChtaW5EaXN0U3EpO1xufVxuXG4vLyBnZXQgcG9seWdvbiBjZW50cm9pZFxuZnVuY3Rpb24gZ2V0Q2VudHJvaWRDZWxsKHBvbHlnb24pIHtcbiAgICB2YXIgYXJlYSA9IDA7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgcG9pbnRzID0gcG9seWdvblswXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuICAgICAgICB2YXIgYSA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIGIgPSBwb2ludHNbal07XG4gICAgICAgIHZhciBmID0gYVswXSAqIGJbMV0gLSBiWzBdICogYVsxXTtcbiAgICAgICAgeCArPSAoYVswXSArIGJbMF0pICogZjtcbiAgICAgICAgeSArPSAoYVsxXSArIGJbMV0pICogZjtcbiAgICAgICAgYXJlYSArPSBmICogMztcbiAgICB9XG4gICAgaWYgKGFyZWEgPT09IDApIHJldHVybiBuZXcgQ2VsbChwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSwgMCwgcG9seWdvbik7XG4gICAgcmV0dXJuIG5ldyBDZWxsKHggLyBhcmVhLCB5IC8gYXJlYSwgMCwgcG9seWdvbik7XG59XG5cbi8vIGdldCBzcXVhcmVkIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIGdldFNlZ0Rpc3RTcShweCwgcHksIGEsIGIpIHtcblxuICAgIHZhciB4ID0gYVswXTtcbiAgICB2YXIgeSA9IGFbMV07XG4gICAgdmFyIGR4ID0gYlswXSAtIHg7XG4gICAgdmFyIGR5ID0gYlsxXSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocHggLSB4KSAqIGR4ICsgKHB5IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IGJbMF07XG4gICAgICAgICAgICB5ID0gYlsxXTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBweCAtIHg7XG4gICAgZHkgPSBweSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polylabel/polylabel.js\n");

/***/ })

};
;